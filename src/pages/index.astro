---
import Layout from '../layouts/Layout.astro';
import Header from '../components/Header.astro';
import ProjectCard from '../components/ProjectCard.astro';
import PostEntry from '../components/PostEntry.astro';

const posts = [
  {
	id: "A001",
    title: "The Latent Space of Design",
    snippet: "Exploring how generative models are rewriting the rules of the International Typographic Style.",
    image: "https://images.unsplash.com/photo-1618005182384-a83a8bd57fbe?q=80&w=800",
    url: "/posts/latent-design",
    date: "2025-05-12" // New property
  },
  {
	id: "A002",
    title: "Automated Aesthetics",
    snippet: "Why the grid is the perfect data structure for AI-mediated layout engines.",
    image: "https://images.unsplash.com/photo-1633167606207-d840b5070fc2?q=80&w=800",
    url: "/posts/automated-aesthetics",
    date: "2025-06-20"
  }
];

const sortedPosts = posts.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
const firstId = sortedPosts[sortedPosts.length - 1].id; // The earliest post ID
const lastId = sortedPosts[0].id;                      // The latest post ID
---

<Layout>
	<div id="canvas-container"></div>
	<main class="relative z-10 grid grid-cols-12 gap-6 px-6 py-12 min-h-screen bg-transparent text-brand-black font-sans">
		<Header version="Ver. 2025.A"/>
		<ProjectCard/>
		
		<div class="col-span-12 border-t-2 border-brand-black mt-24 mb-8 pt-2">
			<span class="font-mono text-[10px] uppercase tracking-widest">
				Selected Feed // {firstId}â€”{lastId}
			</span>
		</div>

		<section class="col-span-12">
			{sortedPosts.map(post => (
				<PostEntry {...post} />
			))}
		</section>
	</main>
	<style>
		#canvas-container {
			position: absolute; 
			top: 0;
			left: 0;
			width: 100%;    /* Takes full width of the viewport */
			height: 100vh;  /* Takes full height of the viewport */
			z-index: 0;
		}
	</style>

	<script>
		import * as THREE from 'three';
		import { gsap } from 'gsap';

		// 1. Setup variables in scope
		let w, h;
		const container = document.getElementById('canvas-container');

		// 2. Initialize Renderer
		const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
		const scene = new THREE.Scene();
		const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000); // Aspect set to 1 for now

		if (container) {
			container.appendChild(renderer.domElement);
			updateSize(); // Initial sizing
		}

		// 3. Reusable Sizing Logic
		function updateSize() {
			if (!container) return;
			w = container.clientWidth;
			h = container.clientHeight;
			
			camera.aspect = w / h;
			camera.updateProjectionMatrix();
			
			renderer.setSize(w, h);
			renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
		}

		// 4. Geometry & Mesh
		const geometry = new THREE.IcosahedronGeometry(2, 2);
		const material = new THREE.MeshBasicMaterial({ 
			color: 0x000000, 
			wireframe: true, 
			transparent: true, 
			opacity: 0.1 
		});
		const sphere = new THREE.Mesh(geometry, material);
		scene.add(sphere);
		camera.position.z = 5;

		// 5. Animations
		gsap.from("#hero-text", {
			y: 100,
			opacity: 0,
			duration: 1.2,
			ease: "expo.out",
			delay: 0.2
		});

		function animate() {
			requestAnimationFrame(animate);
			sphere.rotation.y += 0.003;
			sphere.rotation.x += 0.001;
			renderer.render(scene, camera);
		}
		animate();

		// 6. Listeners
		window.addEventListener('resize', updateSize);
	</script>
</Layout>
